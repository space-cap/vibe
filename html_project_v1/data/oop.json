[
    {
        "category": "객체지향",
        "difficulty": "medium",
        "question": "자바의 4대 객체지향 특성이 아닌 것은?",
        "options": ["캡슐화(Encapsulation)", "상속(Inheritance)", "다형성(Polymorphism)", "컴파일(Compilation)"],
        "correct": 3,
        "explanation": "자바의 4대 객체지향 특성은 캡슐화, 상속, 다형성, 추상화입니다.\n\n📋 4대 객체지향 특성 상세:\n• 캡슐화(Encapsulation): 데이터와 메서드를 하나로 묶고 외부 접근 제한\n• 상속(Inheritance): 기존 클래스의 속성과 메서드를 물려받아 재사용\n• 다형성(Polymorphism): 하나의 인터페이스로 여러 타입의 객체 처리\n• 추상화(Abstraction): 복잡한 내부 구현을 숨기고 필요한 기능만 노출\n\n💡 면접 포인트:\n각 특성이 소프트웨어 개발에 어떤 이점을 제공하는지 실제 예시와 함께 설명할 수 있어야 합니다.\n\n🚫 컴파일(Compilation)은 소스코드를 기계어로 변환하는 과정으로 객체지향 특성이 아닙니다."
    },
    {
        "category": "객체지향",
        "difficulty": "medium",
        "question": "오버로딩(Overloading)과 오버라이딩(Overriding)의 차이점은?",
        "options": [
            "오버로딩은 같은 클래스, 오버라이딩은 상속 관계",
            "오버로딩은 상속 관계, 오버라이딩은 같은 클래스",
            "둘 다 같은 클래스에서만 가능",
            "둘 다 상속 관계에서만 가능"
        ],
        "correct": 0,
        "explanation": "오버로딩과 오버라이딩은 서로 다른 개념입니다.\n\n📋 오버로딩(Overloading) - 컴파일 타임 다형성:\n• 같은 클래스 내에서 수행\n• 메서드 이름은 동일, 매개변수가 달라야 함\n• 반환 타입은 다를 수 있음 (단, 매개변수가 같으면 안됨)\n• 컴파일 시점에 호출할 메서드 결정\n\n💡 오버로딩 예시:\npublic void print(int x) { ... }\npublic void print(String s) { ... }\npublic void print(int x, int y) { ... }\n\n📋 오버라이딩(Overriding) - 런타임 다형성:\n• 상속 관계에서 수행 (부모-자식 클래스)\n• 메서드 시그니처가 완전히 동일해야 함\n• @Override 애너테이션 사용 권장\n• 런타임에 실제 객체 타입에 따라 메서드 결정\n\n🎯 면접 팁: 다형성의 두 가지 형태로 구분하여 설명하면 좋습니다."
    },
    {
        "category": "객체지향",
        "difficulty": "easy",
        "question": "자바에서 클래스와 객체의 차이점은?",
        "options": [
            "클래스는 설계도, 객체는 실제 인스턴스",
            "클래스는 실제 인스턴스, 객체는 설계도",
            "클래스와 객체는 동일한 개념",
            "클래스는 메서드, 객체는 변수"
        ],
        "correct": 0,
        "explanation": "클래스는 객체를 만들기 위한 설계도(blueprint)이고, 객체는 클래스를 바탕으로 생성된 실제 인스턴스입니다.\n\n📋 클래스(Class):\n• 객체의 속성(필드)과 행동(메서드)을 정의하는 틀\n• 메모리에 로드되지만 실제 공간을 차지하지 않음\n• 하나의 클래스로 여러 객체 생성 가능\n\n📋 객체(Object) / 인스턴스(Instance):\n• 클래스를 바탕으로 new 연산자로 생성\n• 힙 메모리에 실제 공간을 차지\n• 각각 독립적인 상태(필드 값)를 가짐\n\n💡 비유:\n• 클래스 = 자동차 설계도면\n• 객체 = 설계도로 만든 실제 자동차\n\n🔧 예시:\nclass Car { ... }        // 클래스 정의\nCar myCar = new Car();   // 객체 생성\nCar yourCar = new Car(); // 다른 객체 생성"
    },
    {
        "category": "객체지향",
        "difficulty": "medium",
        "question": "자바에서 abstract 클래스와 interface의 차이점은?",
        "options": [
            "abstract 클래스는 다중상속 가능, interface는 단일상속만 가능",
            "abstract 클래스는 단일상속만 가능, interface는 다중구현 가능",
            "둘 다 다중상속 가능",
            "둘 다 단일상속만 가능"
        ],
        "correct": 1,
        "explanation": "Abstract 클래스는 단일 상속만 가능하고, Interface는 다중 구현이 가능합니다.\n\n📋 Abstract 클래스:\n• extends 키워드로 상속 (단일 상속)\n• 일반 메서드와 추상 메서드 모두 가질 수 있음\n• 인스턴스 변수(필드) 가질 수 있음\n• 생성자 가질 수 있음\n• 접근 제어자 자유롭게 사용 가능\n\n📋 Interface:\n• implements 키워드로 구현 (다중 구현 가능)\n• Java 8 이전: 추상 메서드만 가능\n• Java 8 이후: default, static 메서드 추가 가능\n• 상수(public static final)만 가질 수 있음\n• 생성자 가질 수 없음\n• 메서드는 기본적으로 public abstract\n\n💡 사용 시기:\n• Abstract 클래스: 공통 구현과 추상 메서드가 모두 필요한 경우\n• Interface: 다중 구현이 필요하거나 계약(contract) 정의 시\n\n🎯 면접 팁: Java 8+ 의 default 메서드 기능도 함께 언급하면 좋습니다."
    },
    {
        "category": "객체지향",
        "difficulty": "hard",
        "question": "자바에서 다형성(Polymorphism)의 구현 방법이 아닌 것은?",
        "options": [
            "메서드 오버라이딩",
            "인터페이스 구현",
            "제네릭 사용",
            "필드 오버로딩"
        ],
        "correct": 3,
        "explanation": "'필드 오버로딩'은 존재하지 않는 개념입니다. 오버로딩은 메서드에만 적용됩니다.\n\n📋 자바에서 다형성 구현 방법:\n\n1️⃣ 메서드 오버라이딩:\n• 상속 관계에서 부모 클래스 메서드를 재정의\n• 런타임에 실제 객체 타입에 따라 메서드 호출\n\n2️⃣ 인터페이스 구현:\n• 같은 인터페이스를 구현한 여러 클래스\n• 인터페이스 참조로 다양한 구현체 사용\n\n3️⃣ 제네릭(Generic):\n• 타입 매개변수를 통한 타입 안정성\n• 하나의 클래스/메서드로 여러 타입 처리\n\n💡 다형성 예시:\nAnimal animal = new Dog(); // 업캐스팅\nanimal.makeSound();        // Dog의 makeSound() 호출\n\nList<String> list = new ArrayList<>(); // 인터페이스 다형성\n\n🚫 필드는 오버로딩 개념이 없습니다:\n• 같은 클래스에서 동일한 이름의 필드 중복 선언 불가\n• 상속 시 필드는 숨겨질 뿐 오버라이딩되지 않음\n\n🎯 면접 포인트: 다형성의 장점(유연성, 확장성, 유지보수성)도 함께 설명"
    },
    {
        "category": "객체지향",
        "difficulty": "hard",
        "question": "자바에서 final 키워드의 용도가 아닌 것은?",
        "options": [
            "변수를 상수로 만들기",
            "메서드 오버라이딩 방지",
            "클래스 상속 방지",
            "객체 가비지 컬렉션 방지"
        ],
        "correct": 3,
        "explanation": "final 키워드는 가비지 컬렉션과는 관련이 없습니다.\n\n📋 final 키워드의 3가지 용도:\n\n1️⃣ 변수에 사용 - 상수 선언:\n• 한 번 초기화 후 값 변경 불가\n• 기본 타입: 값 자체가 상수\n• 참조 타입: 참조 주소가 상수 (객체 내용은 변경 가능)\n\n💡 예시:\nfinal int x = 10;        // x 값 변경 불가\nfinal List<String> list = new ArrayList<>();\n// list = new ArrayList(); // 컴파일 에러\nlist.add(\"item\");       // 내용 변경은 가능\n\n2️⃣ 메서드에 사용 - 오버라이딩 방지:\n• 하위 클래스에서 해당 메서드 재정의 불가\n• 메서드 구현 완성도가 높고 변경이 위험할 때 사용\n\n3️⃣ 클래스에 사용 - 상속 방지:\n• 해당 클래스를 상속받을 수 없음\n• String, Integer 등 Wrapper 클래스들이 final\n• 보안상 중요하거나 불변성이 필요한 클래스에 사용\n\n🚫 가비지 컬렉션은 객체의 참조 여부에 따라 결정되며, final 키워드와는 무관합니다.\n\n🎯 면접 팁: final 변수의 초기화 시점(선언시, 생성자, 초기화 블록)도 알아두면 좋습니다."
    },
    {
        "category": "객체지향",
        "difficulty": "medium",
        "question": "자바에서 생성자(Constructor)의 특징이 아닌 것은?",
        "options": [
            "클래스명과 동일한 이름",
            "반환 타입이 없음",
            "오버로딩 가능",
            "상속될 수 있음"
        ],
        "correct": 3,
        "explanation": "생성자는 상속되지 않습니다. 각 클래스마다 자신의 생성자를 가져야 합니다.\n\n📋 생성자(Constructor)의 특징:\n\n✅ 올바른 특징들:\n\n1️⃣ 클래스명과 동일한 이름:\npublic class User {\n    public User() { } // 클래스명과 일치\n    public User(String name) { } // 동일\n}\n\n2️⃣ 반환 타입이 없음:\n// 잘못된 예시\n// public void User() { } // 이것은 생성자가 아닌 메서드\n\n// 올바른 예시\npublic User() { } // void 도 쓰지 않음\n\n3️⃣ 오버로딩 가능:\npublic class User {\n    public User() { } // 기본 생성자\n    public User(String name) { } // 매개변수 1개\n    public User(String name, int age) { } // 매개변수 2개\n}\n\n❌ 잘못된 특징 - 상속되지 않음:\n• 생성자는 메서드와 달리 상속되지 않음\n• 하위 클래스는 부모 생성자를 자동으로 받지 않음\n• super() 호출로 명시적 연쇄 필요\n\n🔗 상속과 생성자:\n\nclass Parent {\n    public Parent() {\n        System.out.println(\"Parent constructor\");\n    }\n    \n    public Parent(String name) {\n        System.out.println(\"Parent: \" + name);\n    }\n}\n\nclass Child extends Parent {\n    public Child() {\n        // super(); // 암시적으로 호출\n        System.out.println(\"Child constructor\");\n    }\n    \n    public Child(String name) {\n        super(name); // 명시적 호출\n        System.out.println(\"Child: \" + name);\n    }\n}\n\n🚀 생성자 체이닝:\n\nclass User {\n    private String name;\n    private int age;\n    \n    public User() {\n        this(\"기본사용자\", 0); // 다른 생성자 호출\n    }\n    \n    public User(String name) {\n        this(name, 0); // 체이닝\n    }\n    \n    public User(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\n💡 생성자 규칙:\n\n1️⃣ 기본 생성자:\n• 생성자를 정의하지 않으면 컴파일러가 자동 생성\n• 다른 생성자가 있으면 기본 생성자 자동 생성 안됨\n\n2️⃣ 실행 순서:\n• 인스턴스 변수 초기화\n• 인스턴스 초기화 블록 실행\n• 생성자 본문 실행\n\n3️⃣ this(), super() 규칙:\n• 생성자의 첫 번째 라인에서만 사용 가능\n• this()와 super()는 동시 사용 불가\n• super() 호출이 없으면 자동으로 부모 기본 생성자 호출\n\n⚠️ 주의사항:\n\n// 비단 활성 방어\npublic class Singleton {\n    private static Singleton instance;\n    \n    private Singleton() { } // private 생성자로 외부 생성 방지\n    \n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n🔧 생성자 오버로딩 모범 사례:\n\npublic class Rectangle {\n    private double width;\n    private double height;\n    \n    // 기본 정사각형\n    public Rectangle() {\n        this(1.0, 1.0);\n    }\n    \n    // 정사각형 (한 변의 길이)\n    public Rectangle(double side) {\n        this(side, side);\n    }\n    \n    // 일반 직사각형\n    public Rectangle(double width, double height) {\n        this.width = width;\n        this.height = height;\n    }\n    \n    // 복사 생성자\n    public Rectangle(Rectangle other) {\n        this(other.width, other.height);\n    }\n}\n\n🎯 면접 팁: 생성자 체이닝과 상속 관계에서의 동작 방식을 정확히 설명할 수 있어야 합니다."
    },
    {
        "category": "객체지향",
        "difficulty": "hard",
        "question": "자바에서 깊은 복사(Deep Copy)와 얼간 복사(Shallow Copy)의 차이점은?",
        "options": [
            "깊은 복사는 참조만 복사, 얼간 복사는 객체도 복사",
            "깊은 복사는 객체도 복사, 얼간 복사는 참조만 복사",
            "둘 다 동일한 복사 방식",
            "자바에서는 지원하지 않는 개념"
        ],
        "correct": 1,
        "explanation": "깊은 복사는 객체와 그 객체가 참조하는 모든 객체를 복사하지만, 얼간 복사는 객체 자체만 복사하고 내부 참조는 공유합니다.\n\n📋 Shallow Copy vs Deep Copy:\n\n🌊 얼간 복사 (Shallow Copy):\n• 객체의 최상위 레벨만 복사\n• 참조 타입 필드는 동일한 객체를 가리킴\n• 원본 객체의 배열/컴렉션 바뀐이 복사본에 영향\n\n🌋 깊은 복사 (Deep Copy):\n• 객체와 그 객체가 참조하는 모든 객체를 복사\n• 완전히 독립적인 새로운 객체 생성\n• 원본과 복사본이 서로 영향을 주지 않음\n\n💡 실제 예시로 이해하기:\n\nclass Address {\n    String city;\n    String street;\n    \n    public Address(String city, String street) {\n        this.city = city;\n        this.street = street;\n    }\n    \n    public Address(Address other) { // Deep Copy 생성자\n        this.city = other.city;\n        this.street = other.street;\n    }\n}\n\nclass Person implements Cloneable {\n    String name;\n    Address address;\n    \n    public Person(String name, Address address) {\n        this.name = name;\n        this.address = address;\n    }\n    \n    // Shallow Copy (Object.clone() 기본 동작)\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone(); // 참조만 복사\n    }\n    \n    // Deep Copy 메서드\n    public Person deepCopy() {\n        Address copiedAddress = new Address(this.address); // 배열도 새로 생성\n        return new Person(this.name, copiedAddress);\n    }\n}\n\n🔬 비교 예시:\n\n// 원본 객체 생성\nAddress address = new Address(\"서울\", \"강남대로\");\nPerson original = new Person(\"홍길동\", address);\n\n// 1. Shallow Copy\nPerson shallowCopy = (Person) original.clone();\nshallowCopy.address.city = \"부산\"; // 원본에도 영향!\nSystem.out.println(original.address.city); // \"부산\" 출력\n\n// 2. Deep Copy\nPerson deepCopy = original.deepCopy();\ndeepCopy.address.city = \"대구\"; // 원본에 영향 없음\nSystem.out.println(original.address.city); // 여전히 \"서울\" 출력\n\n🔧 Deep Copy 구현 방법:\n\n1️⃣ 복사 생성자 사용:\nclass MyClass {\n    List<String> items;\n    \n    public MyClass(MyClass other) {\n        this.items = new ArrayList<>(other.items); // 새로운 리스트 생성\n    }\n}\n\n2️⃣ 직렬화 활용:\npublic static <T> T deepCopy(T original) {\n    try {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(original);\n        \n        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        ObjectInputStream ois = new ObjectInputStream(bais);\n        return (T) ois.readObject();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n\n3️⃣ 라이브러리 사용 (Apache Commons Lang):\nMyObject copy = SerializationUtils.clone(original);\n\n4️⃣ JSON 직렬화 활용 (Jackson, Gson):\n// Jackson 예시\nObjectMapper mapper = new ObjectMapper();\nString json = mapper.writeValueAsString(original);\nMyClass copy = mapper.readValue(json, MyClass.class);\n\n📊 성능 비교:\n\n| 방법 | 속도 | 메모리 | 안전성 |\n|------|------|--------|---------|\n| Shallow Copy | ★★★ | ★★★ | ★ |\n| 복사 생성자 | ★★ | ★★ | ★★★ |\n| 직렬화 | ★ | ★ | ★★ |\n| JSON | ★ | ★ | ★★ |\n\n⚠️ 주의사항:\n\n1️⃣ Shallow Copy 함정:\n• 배열, 컴렉션 요소 변경 시 원본 영향\n• 예상치 못한 부작용 발생 가능\n\n2️⃣ Deep Copy 함정:\n• 많은 메모리와 CPU 리소스 소모\n• 순환 참조에서 무한 루프 위험\n• 직렬화 불가 객체 문제\n\n🎯 실무 선택 기준:\n• **성능이 중요한 경우**: Shallow Copy + 불변 객체 설계\n• **데이터 안전성이 중요한 경우**: Deep Copy\n• **단순한 객체**: Shallow Copy\n• **복잡한 중첩 객체**: Deep Copy 또는 불변 설계\n\n🔍 면접 팁: 구체적인 사용 사례와 성능상 고려사항을 함께 설명하면 좋습니다."
    }
]
