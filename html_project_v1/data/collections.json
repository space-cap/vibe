[
    {
        "category": "컬렉션",
        "difficulty": "medium",
        "question": "ArrayList와 LinkedList의 주요 차이점은?",
        "options": [
            "ArrayList는 동적 배열, LinkedList는 연결 리스트",
            "ArrayList는 연결 리스트, LinkedList는 동적 배열",
            "둘 다 동적 배열",
            "둘 다 연결 리스트"
        ],
        "correct": 0,
        "explanation": "ArrayList와 LinkedList는 서로 다른 내부 구조를 가집니다.\n\n📋 ArrayList (동적 배열):\n• 내부적으로 Object[] 배열 사용\n• 인덱스 접근: O(1) - 매우 빠름\n• 삽입/삭제: O(n) - 요소 이동 필요\n• 메모리 효율적 (포인터 불필요)\n• 순차 접근에 최적화\n\n📋 LinkedList (이중 연결 리스트):\n• 노드(Node) 객체들을 포인터로 연결\n• 인덱스 접근: O(n) - 순차적으로 탐색\n• 삽입/삭제: O(1) - 포인터만 변경\n• 메모리 오버헤드 (각 노드마다 포인터 저장)\n• 빈번한 삽입/삭제에 최적화\n\n💡 선택 기준:\n• 많은 조회가 필요한 경우 → ArrayList\n• 빈번한 삽입/삭제가 필요한 경우 → LinkedList\n\n🎯 면접 팁: 실제 사용 상황과 성능 특성을 함께 설명하면 좋습니다."
    },
    {
        "category": "컬렉션",
        "difficulty": "hard",
        "question": "HashMap의 시간 복잡도는?",
        "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
        "correct": 0,
        "explanation": "HashMap은 해시 테이블을 사용하여 평균적으로 O(1)의 시간 복잡도를 가집니다.\n\n📋 HashMap 동작 원리:\n• 해시 함수로 key를 해시값으로 변환\n• 해시값을 배열 인덱스로 사용하여 저장/조회\n• 직접 주소 계산으로 빠른 접근 가능\n\n⚡ 시간 복잡도 분석:\n• 평균 경우: O(1) - 해시 충돌이 적을 때\n• 최악 경우: O(n) - 모든 key가 같은 해시값을 가질 때\n\n🔧 해시 충돌 해결:\n• Java 8 이전: Chaining (연결 리스트)\n• Java 8 이후: Chaining + Red-Black Tree (8개 초과시)\n\n📊 성능 최적화:\n• 적절한 초기 용량과 Load Factor(0.75) 설정\n• 좋은 해시 함수로 충돌 최소화\n• equals()와 hashCode() 올바른 구현\n\n💡 TreeMap과 비교:\n• TreeMap: O(log n) 보장, 정렬된 순서 유지\n• HashMap: O(1) 평균, 순서 보장 안함\n\n🎯 면접 포인트: 해시 충돌과 해결 방법, Java 8의 개선사항도 함께 설명"
    },
    {
        "category": "컬렉션",
        "difficulty": "easy",
        "question": "Collection 인터페이스의 주요 하위 인터페이스가 아닌 것은?",
        "options": ["List", "Set", "Queue", "Map"],
        "correct": 3,
        "explanation": "Map은 Collection 인터페이스를 상속받지 않는 별도의 인터페이스입니다.\n\n📋 Java Collections Framework 구조:\n\n🗂️ Collection 인터페이스 계층:\n• List: 순서가 있고 중복 허용 (ArrayList, LinkedList, Vector)\n• Set: 중복을 허용하지 않음 (HashSet, TreeSet, LinkedHashSet)\n• Queue: FIFO 구조 (LinkedList, PriorityQueue, ArrayDeque)\n\n🗂️ Map 인터페이스 (별도 계층):\n• Key-Value 쌍으로 데이터 저장\n• HashMap, TreeMap, LinkedHashMap, Hashtable\n• Collection을 상속받지 않음\n\n💡 이유:\n• Collection: 단일 객체들의 집합\n• Map: Key-Value 쌍의 집합 (다른 개념)\n\n🔧 Map과 Collection의 연결:\n• map.keySet() → Set<K>\n• map.values() → Collection<V>\n• map.entrySet() → Set<Map.Entry<K,V>>\n\n🎯 면접 팁: Collections Framework의 전체 구조를 그림으로 그려서 설명하면 인상적입니다."
    },
    {
        "category": "컬렉션",
        "difficulty": "medium",
        "question": "HashSet과 TreeSet의 차이점은?",
        "options": [
            "HashSet은 정렬, TreeSet은 비정렬",
            "HashSet은 비정렬, TreeSet은 정렬",
            "둘 다 정렬된 상태 유지",
            "둘 다 입력 순서 유지"
        ],
        "correct": 1,
        "explanation": "HashSet은 순서를 보장하지 않고, TreeSet은 자동으로 정렬된 상태를 유지합니다.\n\n📋 HashSet:\n• 해시 테이블 기반 구현\n• 시간 복잡도: O(1) 평균\n• 순서 보장 안함 (무작위 순서)\n• null 값 허용\n• 동기화 되지 않음 (thread-unsafe)\n\n📋 TreeSet:\n• Red-Black Tree (이진 검색 트리) 구현\n• 시간 복잡도: O(log n)\n• 자동 정렬 (자연 순서 또는 Comparator)\n• null 값 허용 안함\n• 동기화 되지 않음\n\n💡 정렬 기준:\n• 자연 순서: Comparable 인터페이스 구현\n• 사용자 정의: Comparator 제공\n\n🔧 사용 예시:\nSet<String> hashSet = new HashSet<>();\nhashSet.add(\"banana\");\nhashSet.add(\"apple\");\n// 결과: [banana, apple] 또는 [apple, banana] (순서 보장 안함)\n\nSet<String> treeSet = new TreeSet<>();\ntreeSet.add(\"banana\");\ntreeSet.add(\"apple\");\n// 결과: [apple, banana] (항상 정렬됨)\n\n⚡ 성능 선택:\n• 빠른 검색이 필요하고 순서가 중요하지 않으면 → HashSet\n• 정렬된 데이터가 필요하면 → TreeSet\n\n🎯 LinkedHashSet도 언급: 입력 순서를 유지하는 HashSet"
    }
]
