[
    {
        "category": "컬렉션",
        "difficulty": "medium",
        "question": "ArrayList와 LinkedList의 주요 차이점은?",
        "options": [
            "ArrayList는 동적 배열, LinkedList는 연결 리스트",
            "ArrayList는 연결 리스트, LinkedList는 동적 배열",
            "둘 다 동적 배열",
            "둘 다 연결 리스트"
        ],
        "correct": 0,
        "explanation": "ArrayList와 LinkedList는 서로 다른 내부 구조를 가집니다.\n\n📋 ArrayList (동적 배열):\n• 내부적으로 Object[] 배열 사용\n• 인덱스 접근: O(1) - 매우 빠름\n• 삽입/삭제: O(n) - 요소 이동 필요\n• 메모리 효율적 (포인터 불필요)\n• 순차 접근에 최적화\n\n📋 LinkedList (이중 연결 리스트):\n• 노드(Node) 객체들을 포인터로 연결\n• 인덱스 접근: O(n) - 순차적으로 탐색\n• 삽입/삭제: O(1) - 포인터만 변경\n• 메모리 오버헤드 (각 노드마다 포인터 저장)\n• 빈번한 삽입/삭제에 최적화\n\n💡 선택 기준:\n• 많은 조회가 필요한 경우 → ArrayList\n• 빈번한 삽입/삭제가 필요한 경우 → LinkedList\n\n🎯 면접 팁: 실제 사용 상황과 성능 특성을 함께 설명하면 좋습니다."
    },
    {
        "category": "컬렉션",
        "difficulty": "hard",
        "question": "HashMap의 시간 복잡도는?",
        "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
        "correct": 0,
        "explanation": "HashMap은 해시 테이블을 사용하여 평균적으로 O(1)의 시간 복잡도를 가집니다.\n\n📋 HashMap 동작 원리:\n• 해시 함수로 key를 해시값으로 변환\n• 해시값을 배열 인덱스로 사용하여 저장/조회\n• 직접 주소 계산으로 빠른 접근 가능\n\n⚡ 시간 복잡도 분석:\n• 평균 경우: O(1) - 해시 충돌이 적을 때\n• 최악 경우: O(n) - 모든 key가 같은 해시값을 가질 때\n\n🔧 해시 충돌 해결:\n• Java 8 이전: Chaining (연결 리스트)\n• Java 8 이후: Chaining + Red-Black Tree (8개 초과시)\n\n📊 성능 최적화:\n• 적절한 초기 용량과 Load Factor(0.75) 설정\n• 좋은 해시 함수로 충돌 최소화\n• equals()와 hashCode() 올바른 구현\n\n💡 TreeMap과 비교:\n• TreeMap: O(log n) 보장, 정렬된 순서 유지\n• HashMap: O(1) 평균, 순서 보장 안함\n\n🎯 면접 포인트: 해시 충돌과 해결 방법, Java 8의 개선사항도 함께 설명"
    },
    {
        "category": "컬렉션",
        "difficulty": "easy",
        "question": "Collection 인터페이스의 주요 하위 인터페이스가 아닌 것은?",
        "options": ["List", "Set", "Queue", "Map"],
        "correct": 3,
        "explanation": "Map은 Collection 인터페이스를 상속받지 않는 별도의 인터페이스입니다.\n\n📋 Java Collections Framework 구조:\n\n🗂️ Collection 인터페이스 계층:\n• List: 순서가 있고 중복 허용 (ArrayList, LinkedList, Vector)\n• Set: 중복을 허용하지 않음 (HashSet, TreeSet, LinkedHashSet)\n• Queue: FIFO 구조 (LinkedList, PriorityQueue, ArrayDeque)\n\n🗂️ Map 인터페이스 (별도 계층):\n• Key-Value 쌍으로 데이터 저장\n• HashMap, TreeMap, LinkedHashMap, Hashtable\n• Collection을 상속받지 않음\n\n💡 이유:\n• Collection: 단일 객체들의 집합\n• Map: Key-Value 쌍의 집합 (다른 개념)\n\n🔧 Map과 Collection의 연결:\n• map.keySet() → Set<K>\n• map.values() → Collection<V>\n• map.entrySet() → Set<Map.Entry<K,V>>\n\n🎯 면접 팁: Collections Framework의 전체 구조를 그림으로 그려서 설명하면 인상적입니다."
    },
    {
        "category": "컬렉션",
        "difficulty": "medium",
        "question": "HashSet과 TreeSet의 차이점은?",
        "options": [
            "HashSet은 정렬, TreeSet은 비정렬",
            "HashSet은 비정렬, TreeSet은 정렬",
            "둘 다 정렬된 상태 유지",
            "둘 다 입력 순서 유지"
        ],
        "correct": 1,
        "explanation": "HashSet은 순서를 보장하지 않고, TreeSet은 자동으로 정렬된 상태를 유지합니다.\n\n📋 HashSet:\n• 해시 테이블 기반 구현\n• 시간 복잡도: O(1) 평균\n• 순서 보장 안함 (무작위 순서)\n• null 값 허용\n• 동기화 되지 않음 (thread-unsafe)\n\n📋 TreeSet:\n• Red-Black Tree (이진 검색 트리) 구현\n• 시간 복잡도: O(log n)\n• 자동 정렬 (자연 순서 또는 Comparator)\n• null 값 허용 안함\n• 동기화 되지 않음\n\n💡 정렬 기준:\n• 자연 순서: Comparable 인터페이스 구현\n• 사용자 정의: Comparator 제공\n\n🔧 사용 예시:\nSet<String> hashSet = new HashSet<>();\nhashSet.add(\"banana\");\nhashSet.add(\"apple\");\n// 결과: [banana, apple] 또는 [apple, banana] (순서 보장 안함)\n\nSet<String> treeSet = new TreeSet<>();\ntreeSet.add(\"banana\");\ntreeSet.add(\"apple\");\n// 결과: [apple, banana] (항상 정렬됨)\n\n⚡ 성능 선택:\n• 빠른 검색이 필요하고 순서가 중요하지 않으면 → HashSet\n• 정렬된 데이터가 필요하면 → TreeSet\n\n🎯 LinkedHashSet도 언급: 입력 순서를 유지하는 HashSet"
    },
    {
        "category": "컴렉션",
        "difficulty": "hard",
        "question": "Java 8에서 HashMap에 도입된 개선사항은?",
        "options": [
            "대용량 데이터 지원",
            "충돌 시 Red-Black Tree 사용",
            "다중 스레드 안전성",
            "자동 리사이징"
        ],
        "correct": 1,
        "explanation": "Java 8에서 HashMap은 해시 충돌이 많이 발생할 때 Red-Black Tree를 사용하여 성능을 개선했습니다.\n\n📋 Java 8 HashMap 개선사항:\n\n🌳 Tree화 (Treeify) 전략:\n• 동일 버킷에 연결된 노드 수가 8개 초과 시 Red-Black Tree 로 변환\n• 노드 수가 6개 이하로 감소 시 Linked List로 되돌린\n• 최악의 경우 O(n) → O(log n)으로 성능 개선\n\n🔍 상세 동작 원리:\n\n1️⃣ 기본 구조 (체이닝):\n• 각 버킷에는 Linked List로 충돌 노드 저장\n• 충돌이 적을 때는 O(1) 성능\n• 충돌이 많아지면 O(n) 성능 저하\n\n2️⃣ Tree화 조건:\n• 버킷 내 노드 수 > TREEIFY_THRESHOLD (8)\n• 전체 테이블 크기 > MIN_TREEIFY_CAPACITY (64)\n• Key 타입이 Comparable 인터페이스 구현\n\n3️⃣ 언트리화 (Untreeify) 조건:\n• 버킷 내 노드 수 < UNTREEIFY_THRESHOLD (6)\n• remove 연산 시 자동으로 Linked List로 변환\n\n🌳 Red-Black Tree 특징:\n• 자가 균형 이진 탐색 트리\n• 최대 높이: 2 * log₂(n + 1)\n• 삽입, 삭제, 탐색 모든 O(log n) 보장\n• AVL 트리보다 삽입/삭제 성능 우수\n\n📊 성능 비교:\n\n| 연산 | Java 7 최악 | Java 8 최악 |\n|------|-------------|-------------|\n| GET | O(n) | O(log n) |\n| PUT | O(n) | O(log n) |\n| REMOVE | O(n) | O(log n) |\n\n💡 실제 효과:\n• 해시 충돌 공격(Hash Collision Attack) 방어\n• 대량 데이터에서 안정적 성능 보장\n• 최악의 경우에도 허용 가능한 성능\n\n🔧 구현 예시:\n\n// Tree 노드 구조\nstatic final class TreeNode<K,V> extends Node<K,V> {\n    TreeNode<K,V> parent;\n    TreeNode<K,V> left;\n    TreeNode<K,V> right;\n    TreeNode<K,V> prev;\n    boolean red; // Red-Black Tree의 색상 정보\n}\n\n// Tree화 결정 로직\nif (binCount >= TREEIFY_THRESHOLD - 1) {\n    treeifyBin(tab, hash); // Linked List → Red-Black Tree\n}\n\n⚠️ 주의사항:\n• Key 클래스에 Comparable 미구현 시 성능 저하 가능\n• 메모리 사용량 약간 증가 (트리 노드 오버헤드)\n• 여전히 스레드 안전하지 않음 (ConcurrentHashMap 사용 권장)\n\n🎯 면접 팁: 이 개선사항이 실제 서비스에 미치는 영향을 설명할 수 있으면 좋습니다."
    },
    {
        "category": "컴렉션",
        "difficulty": "medium",
        "question": "ConcurrentHashMap과 HashMap의 주요 차이점은?",
        "options": [
            "ConcurrentHashMap은 스레드 안전, HashMap은 스레드 비안전",
            "ConcurrentHashMap은 느림, HashMap은 빠름",
            "ConcurrentHashMap은 정렬 보장, HashMap은 비정렬",
            "ConcurrentHashMap은 null 허용, HashMap은 null 비허용"
        ],
        "correct": 0,
        "explanation": "ConcurrentHashMap은 멀티스레드 환경에서 스레드 안전성을 보장하는 동시성 컴렉션입니다.\n\n📋 HashMap vs ConcurrentHashMap 비교:\n\n🚫 HashMap (비스레드 안전):\n• 단일 스레드 환경에서 사용\n• 멀티스레드에서 데이터 손상 가능\n• 무한 루프, 데이터 손실 등 문제 발생\n• null key, null value 허용\n• 빠른 성능 (동기화 오버헤드 없음)\n\n✅ ConcurrentHashMap (스레드 안전):\n• 멀티스레드 환경에서 안전한 사용\n• 부분 잠금(Segment Locking) 사용 (Java 8 이전)\n• CAS(Compare-And-Swap) 연산 사용 (Java 8 이후)\n• null key, null value 비허용\n• 약간의 성능 오버헤드\n\n🔧 ConcurrentHashMap 동시성 메커니즘:\n\n🔐 Java 8 이전 (Segment Locking):\n• 내부를 16개 세그먼트로 분할\n• 각 세그먼트 별로 독립적인 잠금\n• 동시 접근 가능한 스레드 수 = 세그먼트 수\n\n🧠 Java 8 이후 (CAS + synchronized):\n• 세그먼트 구조 제거\n• CAS 연산으로 노드 삽입 시도\n• 충돌 시만 synchronized 블록 사용\n• 더 세밀한 동시성 제어\n\n💡 주요 메서드 동시성:\n\n• **get()**: 잠금 없이 실행 (읽기 전용)\n• **put()**: CAS + synchronized 사용\n• **remove()**: synchronized 블록 사용\n• **size()**: 전체 계수 연산 (비정확할 수 있음)\n\n📦 주요 메서드 비교:\n\n| 메서드 | HashMap | ConcurrentHashMap |\n|--------|---------|-------------------|\n| get() | O(1) 빠름 | O(1) 빠름 |\n| put() | O(1) 빠름 | O(1) 비교적 느림 |\n| size() | O(1) | O(n) 비싸다 |\n| 순회 | Fail-fast | 약한 일관성 |\n\n🚀 성능 최적화:\n\n// 읽기 전용 작업에는 HashMap 사용\nMap<String, String> readOnlyMap = new HashMap<>();\n\n// 동시 읽기/쓰기에는 ConcurrentHashMap 사용\nMap<String, String> concurrentMap = new ConcurrentHashMap<>();\n\n// 대안: Collections.synchronizedMap() (권장하지 않음)\nMap<String, String> syncMap = Collections.synchronizedMap(new HashMap<>());\n\n🔒 실무 사용 가이드:\n\n• **단일 스레드**: HashMap 사용\n• **링크 전용**: HashMap 사용 (Collections.unmodifiableMap())\n• **다중 스레드 읽기/쓰기**: ConcurrentHashMap 사용\n• **웹 애플리케이션 캐시**: ConcurrentHashMap 사용\n\n⚠️ 주의사항:\n• ConcurrentHashMap도 완벽한 atomic 연산을 보장하지는 않음\n• putIfAbsent(), replace(), remove() 등 atomic 메서드 활용\n• 순회 중 수정 시 예상치 못한 동작 가능\n\n🎯 면접 팁: 실제 프로젝트에서 언제 ConcurrentHashMap을 선택했는지 경험을 들는 것이 좋습니다."
    },
    {
        "category": "컴렉션",
        "difficulty": "easy",
        "question": "ArrayList의 기본 용량(capacity)은?",
        "options": ["5", "10", "16", "32"],
        "correct": 1,
        "explanation": "ArrayList의 기본 초기 용량은 10입니다.\n\n📋 ArrayList 용량 관리:\n\n📦 초기 용량:\n• 기본 생성자: new ArrayList<>() → 초기 용량 10\n• 빈 리스트: Collections.emptyList() → 용량 0\n• 지정 생성자: new ArrayList<>(20) → 용량 20\n\n📊 용량 확장 알고리즘:\n• 현재 용량이 부족할 때 자동 확장\n• 새로운 용량 = 기존 용량 * 1.5 (3/2 배)\n• 최대 용량: Integer.MAX_VALUE - 8\n\n💡 확장 과정 예시:\n0 → 10 → 15 → 22 → 33 → 49 → 73 → 109...\n\n🔧 내부 구조:\n\n// ArrayList 내부 구현 (단순화)\npublic class ArrayList<E> {\n    private static final int DEFAULT_CAPACITY = 10;\n    private Object[] elementData; // 데이터 저장 배열\n    private int size; // 실제 요소 개수\n    \n    public ArrayList() {\n        this.elementData = new Object[DEFAULT_CAPACITY];\n    }\n}\n\n⚡ 확장 연산 비용:\n• 새로운 배열 생성: O(1)\n• 기존 데이터 복사: O(n)\n• 참조 업데이트: O(1)\n\n🚀 성능 최적화 팁:\n\n1️⃣ 초기 용량 지정:\n// 예상 요소 수가 100개라면\nList<String> list = new ArrayList<>(100);\n\n2️⃣ 대량 데이터 삽입 시:\n// 잘못된 방법: 빈번한 확장\nList<Integer> list = new ArrayList<>();\nfor (int i = 0; i < 10000; i++) {\n    list.add(i); // 여러 번 배열 재할당\n}\n\n// 올바른 방법: 미리 용량 확보\nList<Integer> list = new ArrayList<>(10000);\nfor (int i = 0; i < 10000; i++) {\n    list.add(i); // 배열 재할당 없음\n}\n\n3️⃣ 메모리 절약:\n// 사용하지 않는 용량 제거\nlist.trimToSize(); // 내부 배열 크기를 size()로 조정\n\n📊 메모리 사용량 분석:\n\n// 용량 100, 실제 요소 50개인 경우\n• 사용 중인 메모리: 50개 요소\n• 낭비되는 메모리: 50개 노드의 공간\n• 오버헤드: 약 100%\n\n🔍 실무 사용법:\n\n// 1. 예상 사이즈를 알 때\nList<User> users = new ArrayList<>(expectedSize);\n\n// 2. 기존 컴렉션에서 변환\nList<String> list = new ArrayList<>(existingCollection);\n\n// 3. 성능이 중요한 경우\nList<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));\n\n🔄 다른 List 구현체와 비교:\n• **Vector**: 초기 용량 10, 2배씩 확장 (동기화됨)\n• **LinkedList**: 동적 노드 할당 (초기 용량 개념 없음)\n• **ArrayDeque**: 초기 용량 16, 2배씩 확장\n\n🎯 면접 팁: ArrayList의 성능 특성과 용량 관리 전략을 함께 설명하면 좋습니다."
    }
]
