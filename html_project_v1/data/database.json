[
    {
        "category": "데이터베이스",
        "difficulty": "medium",
        "question": "JPA에서 @Entity와 @Table의 차이점은?",
        "options": [
            "@Entity는 클래스 매핑, @Table은 테이블 매핑",
            "@Entity는 테이블 매핑, @Table은 클래스 매핑",
            "둘 다 동일한 기능",
            "@Table은 존재하지 않는 애너테이션"
        ],
        "correct": 0,
        "explanation": "@Entity는 JPA 엔티티 클래스임을 선언하고, @Table은 매핑할 데이터베이스 테이블을 지정합니다.\n\n📋 @Entity:\n• JPA가 관리하는 엔티티 클래스임을 표시\n• 필수 애너테이션\n• 기본 생성자 필수\n• final, enum, interface, inner 클래스에는 사용 불가\n\n📋 @Table:\n• 매핑할 테이블명 지정 (선택적)\n• 생략시 클래스명을 테이블명으로 사용\n• schema, catalog 속성으로 스키마 지정 가능\n• uniqueConstraints로 유니크 제약조건 설정\n\n💡 사용 예시:\n@Entity\n@Table(name = \"users\", schema = \"hr\")\npublic class User {\n    // 필드와 메서드\n}\n\n🎯 실무 팁:\n• 테이블명이 클래스명과 다를 때만 @Table 사용\n• 네이밍 전략(NamingStrategy) 설정으로 일관된 매핑 가능"
    },
    {
        "category": "데이터베이스",
        "difficulty": "hard",
        "question": "JPA의 영속성 컨텍스트(Persistence Context)의 주요 기능은?",
        "options": [
            "SQL 쿼리 자동 생성",
            "엔티티의 생명주기 관리와 1차 캐시 제공",
            "데이터베이스 연결 관리",
            "트랜잭션 롤백 처리"
        ],
        "correct": 1,
        "explanation": "영속성 컨텍스트는 엔티티의 생명주기를 관리하고 1차 캐시, 동일성 보장, 변경 감지 등의 기능을 제공합니다.\n\n📋 영속성 컨텍스트의 주요 기능:\n\n🗂️ 1차 캐시 (First Level Cache):\n• 트랜잭션 범위 내에서 엔티티 캐싱\n• 같은 ID로 조회 시 DB 접근 없이 캐시에서 반환\n• 성능 향상 효과\n\n🔍 동일성 보장 (Identity):\n• 같은 트랜잭션 내에서 같은 엔티티 보장\n• == 비교가 가능 (동일한 인스턴스 참조)\n\n🔄 변경 감지 (Dirty Checking):\n• 엔티티 상태 변화 자동 감지\n• 트랜잭션 커밋 시 자동으로 UPDATE 쿼리 실행\n• 명시적인 save() 호출 불필요\n\n💾 쓰기 지연 (Write-behind):\n• SQL 쿼리를 쓰기 지연 저장소에 모아둠\n• 트랜잭션 커밋 시점에 한번에 DB로 전송\n• 성능 최적화와 트랜잭션 무결성 보장\n\n📊 엔티티 생명주기 관리:\n• 비영속 (new/transient): 새로 생성된 상태\n• 영속 (managed): 영속성 컨텍스트에 저장된 상태\n• 준영속 (detached): 영속성 컨텍스트에서 분리된 상태\n• 삭제 (removed): 삭제하기로 예정된 상태\n\n💡 실무 중요점:\n• EntityManager가 영속성 컨텍스트의 관리자 역할\n• 트랜잭션 단위로 동작\n• N+1 문제 등 성능 이슈 고려 필요"
    },
    {
        "category": "데이터베이스",
        "difficulty": "medium",
        "question": "Spring Data JPA에서 쿼리 메서드 네이밍 규칙으로 올바른 것은?",
        "options": [
            "getUserByName(String name)",
            "findByName(String name)",
            "selectByName(String name)",
            "getByName(String name)"
        ],
        "correct": 1,
        "explanation": "Spring Data JPA는 특정 네이밍 규칙을 따라 메서드명으로 쿼리를 자동 생성합니다.\n\n📋 쿼리 메서드 네이밍 규칙:\n\n🔍 주요 키워드:\n• find...By, read...By, get...By, query...By, stream...By\n• count...By: 개수 반환\n• exists...By: 존재 여부 (boolean)\n• delete...By, remove...By: 삭제\n\n💡 조건 키워드:\n• And: findByNameAndAge\n• Or: findByNameOrAge\n• Between: findByAgeBetween\n• LessThan: findByAgeL essThan\n• GreaterThan: findByAgeGreaterThan\n• Like: findByNameLike\n• In: findByNameIn\n• IsNull: findByNameIsNull\n• OrderBy: findByNameOrderByAgeDesc\n\n🔧 사용 예시:\nList<User> findByName(String name);\nList<User> findByNameAndAge(String name, int age);\nList<User> findByAgeGreaterThan(int age);\nList<User> findByNameLike(String namePattern);\nList<User> findByNameIn(List<String> names);\nlong countByAge(int age);\nboolean existsByEmail(String email);\nvoid deleteByName(String name);\n\n⚙️ 고급 기능:\n• @Query 애너테이션으로 직접 JPQL 작성\n• 네이티브 쿼리 지원\n• 페이징과 정렬 지원 (Pageable, Sort)\n\n🎯 실무 팁:\n• 복잡한 쿼리는 @Query 사용 권장\n• 메서드명이 너무 길어지면 가독성 저하\n• 성능이 중요한 쿼리는 튜닝 필요"
    },
    {
        "category": "데이터베이스",
        "difficulty": "easy",
        "question": "JPA에서 기본키(Primary Key)를 나타내는 애너테이션은?",
        "options": [
            "@PrimaryKey",
            "@Key",
            "@Id",
            "@Identity"
        ],
        "correct": 2,
        "explanation": "@Id 애너테이션을 사용하여 엔티티의 기본키 필드를 지정합니다.\n\n📋 @Id 애너테이션:\n• JPA에서 기본키를 지정하는 필수 애너테이션\n• 모든 엔티티는 반드시 @Id를 가져야 함\n• 기본 타입과 래퍼 클래스 모두 사용 가능\n\n💡 사용 예시:\n@Entity\npublic class User {\n    @Id\n    private Long id;\n    \n    private String name;\n    // getter, setter...\n}\n\n🔧 기본키 생성 전략 (@GeneratedValue):\n• GenerationType.IDENTITY: DB의 AUTO_INCREMENT 사용\n• GenerationType.SEQUENCE: DB 시퀀스 사용\n• GenerationType.TABLE: 키 생성용 테이블 사용\n• GenerationType.AUTO: DB에 따라 자동 선택\n\n💡 생성 전략 예시:\n@Id\n@GeneratedValue(strategy = GenerationType.IDENTITY)\nprivate Long id;\n\n🎯 복합키 (Composite Key):\n• @EmbeddedId: 복합키 클래스 사용\n• @IdClass: 별도 ID 클래스 지정\n\n⚠️ 주의사항:\n• @Id는 null 값을 가질 수 없음\n• equals()와 hashCode() 올바른 구현 권장"
    },
    {
        "category": "데이터베이스",
        "difficulty": "hard",
        "question": "JPA의 연관관계 매핑에서 @JoinColumn의 역할은?",
        "options": [
            "조인 테이블을 생성",
            "외래키 컬럼을 지정",
            "연관관계의 주인을 설정",
            "카스케이드 옵션을 설정"
        ],
        "correct": 1,
        "explanation": "@JoinColumn은 연관관계 매핑에서 외래키(Foreign Key) 컬럼의 정보를 지정하는 애너테이션입니다.\n\n📋 @JoinColumn의 역할:\n• 외래키 컬럼명 지정\n• 외래키 제약조건 설정\n• 연관관계 매핑 시 조인할 컬럼 명시\n• 생략 시 기본 규칙에 따라 자동 생성\n\n💡 주요 속성:\n• name: 외래키 컬럼명\n• referencedColumnName: 참조할 대상 테이블의 컬럼명\n• nullable: null 허용 여부\n• unique: 유니크 제약조건\n• foreignKey: 외래키 제약조건 설정\n\n🔧 사용 예시:\n// 다대일 관계\n@Entity\npublic class Order {\n    @ManyToOne\n    @JoinColumn(name = \"user_id\", referencedColumnName = \"id\")\n    private User user;\n}\n\n// 일대일 관계\n@Entity\npublic class User {\n    @OneToOne\n    @JoinColumn(name = \"profile_id\")\n    private Profile profile;\n}\n\n🔄 양방향 연관관계에서:\n// 연관관계의 주인 (Owner)\n@Entity\npublic class Order {\n    @ManyToOne\n    @JoinColumn(name = \"user_id\")\n    private User user;\n}\n\n// 피소유자 (Non-Owner)\n@Entity\npublic class User {\n    @OneToMany(mappedBy = \"user\")\n    private List<Order> orders;\n}\n\n⚠️ 중요 개념:\n• 연관관계의 주인만 외래키를 관리\n• mappedBy는 연관관계의 주인이 아닌 쪽에서 사용\n• @JoinColumn은 연관관계의 주인 쪽에서 사용\n\n🎯 실무 팁:\n• 외래키 컬럼명을 명확히 지정하여 가독성 향상\n• 데이터베이스 네이밍 규칙과 일치시키기\n• nullable, unique 등 제약조건 적절히 활용"
    }
]
