[
    {
        "category": "멀티스레딩",
        "difficulty": "hard",
        "question": "synchronized 키워드의 역할은?",
        "options": [
            "스레드 간 동기화를 보장",
            "스레드 생성 속도를 향상",
            "메모리 사용량을 최적화",
            "예외 처리를 자동화"
        ],
        "correct": 0,
        "explanation": "synchronized 키워드는 멀티스레드 환경에서 공유 자원에 대한 동시 접근을 제어하여 스레드 안전성을 보장합니다.\n\n📋 synchronized의 역할:\n• 임계 구역(Critical Section) 설정\n• 한 번에 하나의 스레드만 접근 허용\n• 객체/클래스 레벨의 락(Lock) 사용\n• 메모리 가시성(Visibility) 보장\n\n🔧 사용 방법:\n1️⃣ 메서드 동기화:\npublic synchronized void method() { ... }\n\n2️⃣ 블록 동기화:\nsynchronized(this) { ... }     // 인스턴스 락\nsynchronized(Class.class) { ... } // 클래스 락\n\n⚠️ 성능 고려사항:\n• 락 경합으로 인한 성능 저하\n• 데드락 위험성\n• 과도한 동기화는 병목 발생\n\n🆚 대안 기술:\n• java.util.concurrent 패키지\n• ReentrantLock, Atomic 클래스\n• ConcurrentHashMap 등\n\n💡 면접 팁:\n동기화의 필요성과 문제점, 그리고 최신 동시성 도구들과의 비교를 함께 설명하면 좋습니다."
    },
    {
        "category": "멀티스레딩",
        "difficulty": "medium",
        "question": "Thread의 생명주기에서 올바른 상태 전이는?",
        "options": [
            "NEW → RUNNABLE → RUNNING → TERMINATED",
            "NEW → RUNNABLE → BLOCKED → TERMINATED",
            "NEW → RUNNABLE → WAITING → RUNNABLE → TERMINATED",
            "NEW → RUNNING → RUNNABLE → TERMINATED"
        ],
        "correct": 2,
        "explanation": "스레드는 다양한 상태 간 전이가 가능하며, WAITING 후 다시 RUNNABLE로 돌아갈 수 있습니다.\n\n📋 Thread 상태 (Thread.State):\n\n🟢 NEW: 스레드 생성, 아직 start() 호출 안됨\n🔵 RUNNABLE: 실행 가능한 상태 (실행 중 또는 실행 대기)\n🟡 BLOCKED: 동기화 블록 진입을 위해 락 대기\n🟠 WAITING: 다른 스레드의 특정 작업을 무한정 대기\n⏰ TIMED_WAITING: 지정된 시간 동안 대기\n🔴 TERMINATED: 실행 완료 또는 예외로 종료\n\n🔄 상태 전이 예시:\nNEW → start() → RUNNABLE\nRUNNABLE → sleep(1000) → TIMED_WAITING → RUNNABLE\nRUNNABLE → wait() → WAITING → notify() → RUNNABLE\nRUNNABLE → synchronized 진입 실패 → BLOCKED → RUNNABLE\n\n💡 중요 포인트:\n• RUNNING 상태는 JVM 내부적으로만 존재\n• Java API에서는 RUNNABLE로 표현\n• 여러 상태를 거쳐 최종적으로 TERMINATED\n\n🔧 상태 확인 방법:\nThread.currentThread().getState();"
    },
    {
        "category": "멀티스레딩",
        "difficulty": "medium",
        "question": "volatile 키워드의 주요 기능은?",
        "options": [
            "변수를 final로 만들기",
            "메모리 가시성 보장",
            "스레드 동기화",
            "성능 최적화"
        ],
        "correct": 1,
        "explanation": "volatile 키워드는 변수의 메모리 가시성(Visibility)을 보장합니다.\n\n📋 volatile의 기능:\n• 메인 메모리에서 직접 읽기/쓰기\n• CPU 캐시가 아닌 메인 메모리 접근\n• 다른 스레드의 변경사항 즉시 반영\n• 컴파일러 최적화 방지\n\n🔧 사용 예시:\nprivate volatile boolean flag = false;\n\n// Thread 1\nflag = true;\n\n// Thread 2\nwhile (!flag) {\n    // Thread 1의 변경사항을 즉시 감지\n}\n\n⚠️ 주의사항:\n• 단순 읽기/쓰기에만 원자성 보장\n• 복합 연산 (++, --) 에는 원자성 보장 안함\n• synchronized보다 가벼우나 기능 제한적\n\n🚫 안전하지 않은 예:\nvolatile int count = 0;\ncount++; // 읽기 + 증가 + 쓰기 (원자적이지 않음)\n\n✅ 안전한 사용 패턴:\n• 상태 플래그 (boolean)\n• 싱글톤의 인스턴스 참조\n• 단순한 값 전달\n\n💡 Double-Checked Locking 패턴에서 필수:\nprivate volatile static Singleton instance;"
    },
    {
        "category": "멀티스레딩",
        "difficulty": "hard",
        "question": "java.util.concurrent.ExecutorService의 주요 장점은?",
        "options": [
            "스레드 풀 관리와 라이프사이클 제어",
            "스레드 생성 속도 향상",
            "메모리 사용량 감소",
            "동기화 성능 향상"
        ],
        "correct": 0,
        "explanation": "ExecutorService는 스레드의 생성, 관리, 종료를 체계적으로 처리하는 높은 수준의 동시성 API입니다.\n\n📋 ExecutorService의 주요 장점:\n\n🏊‍♂️ 스레드 풀 관리:\n• 미리 생성된 스레드 풀 사용\n• 스레드 생성/소멸 비용 절약\n• 시스템 리소스 효율적 활용\n• 동시 실행 스레드 수 제한\n\n🔄 라이프사이클 제어:\n•작업 제출, 취소, 완료 대기\n•우아한 종료 (graceful shutdown)\n• 이미 실행 중인 작업 완료 후 종료\n• 강제 종료 (forceful shutdown)\n\n🔧 주요 구현체:\n\n1️⃣ ThreadPoolExecutor:\n• 가장 일반적인 스레드 풀 구현\n• 코어 풀 크기, 최대 풀 크기 설정 가능\n• 작업 큐 선택 가능\n\n2️⃣ ScheduledThreadPoolExecutor:\n• 지연 실행 및 주기적 실행 지원\n• Timer의 개선된 버전\n\n3️⃣ ForkJoinPool:\n• 재귀적 분할 정복 작업에 최적화\n• work-stealing 알고리즘 사용\n\n💡 사용 예시:\n\n// 1. 고정 크기 스레드 풀\nExecutorService executor = Executors.newFixedThreadPool(5);\n\n// 2. 작업 제출\nFuture<String> future = executor.submit(() -> {\n    return \"Hello World\";\n});\n\n// 3. 결과 수신\ntry {\n    String result = future.get(5, TimeUnit.SECONDS); // 5초 대기\n    System.out.println(result);\n} catch (TimeoutException e) {\n    future.cancel(true); // 작업 취소\n}\n\n// 4. 스레드 풀 종료\nexecutor.shutdown();\ntry {\n    if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {\n        executor.shutdownNow(); // 강제 종료\n    }\n} catch (InterruptedException e) {\n    executor.shutdownNow();\n}\n\n🚀 Executors 팩토리 메서드:\n\n• **newFixedThreadPool(n)**: 고정 크기 스레드 풀\n• **newCachedThreadPool()**: 필요에 따라 스레드 생성/소멸\n• **newSingleThreadExecutor()**: 단일 스레드 순차 처리\n• **newScheduledThreadPool(n)**: 지연/주기적 작업 처리\n• **newWorkStealingPool()**: ForkJoinPool 기반\n\n📊 성능 최적화:\n\n// 사용자 정의 ThreadPoolExecutor\nThreadPoolExecutor executor = new ThreadPoolExecutor(\n    5,                      // 코어 풀 크기\n    10,                     // 최대 풀 크기\n    60L, TimeUnit.SECONDS,  // 유지 시간\n    new ArrayBlockingQueue<>(100), // 작업 큐\n    new ThreadPoolExecutor.CallerRunsPolicy() // 거절 정책\n);\n\n🔐 동시성 지원:\n\n// CompletableFuture와 함께 사용\nCompletableFuture<String> future = CompletableFuture\n    .supplyAsync(() -> \"Hello\", executor)\n    .thenApply(s -> s + \" World\")\n    .thenApply(String::toUpperCase);\n\n// 병렬 스트림 처리\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\nForkJoinPool customThreadPool = new ForkJoinPool(4);\ntry {\n    Integer sum = customThreadPool.submit(() ->\n        numbers.parallelStream().reduce(0, Integer::sum)\n    ).get();\n} finally {\n    customThreadPool.shutdown();\n}\n\n⚠️ 주의사항:\n\n1️⃣ 자원 누수 방지:\n• 반드시 shutdown() 호출\n• try-with-resources 사용 권장\n\n2️⃣ 적절한 풀 크기 선택:\n• CPU 집약적 작업: CPU 코어 수\n• I/O 집약적 작업: CPU 코어 수 * 2\n\n3️⃣ 예외 처리:\n• 작업 내 예외는 스레드 풀에 영향 없음\n• 미처리 예외는 스레드 종료 일으탴 수 있음\n\n🎯 실무 모범 사례:\n\n@Component\npublic class AsyncService {\n    private final ExecutorService executor = \n        Executors.newFixedThreadPool(10);\n    \n    @PreDestroy\n    public void shutdown() {\n        executor.shutdown();\n        try {\n            if (!executor.awaitTermination(30, TimeUnit.SECONDS)) {\n                executor.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            executor.shutdownNow();\n            Thread.currentThread().interrupt();\n        }\n    }\n    \n    public CompletableFuture<String> processAsync(String data) {\n        return CompletableFuture.supplyAsync(() -> {\n            // 비동기 처리 로직\n            return process(data);\n        }, executor);\n    }\n}\n\n🔍 면접 팁: 실제 프로젝트에서 ExecutorService를 어떻게 활용했는지, 어떤 문제를 해결했는지 경험을 들어도 좋습니다."
    },
    {
        "category": "멀티스레딩",
        "difficulty": "medium",
        "question": "CountDownLatch와 CyclicBarrier의 차이점은?",
        "options": [
            "CountDownLatch는 재사용 가능, CyclicBarrier는 일회용",
            "CountDownLatch는 일회용, CyclicBarrier는 재사용 가능",
            "둘 다 일회용",
            "둘 다 재사용 가능"
        ],
        "correct": 1,
        "explanation": "CountDownLatch는 일회용이지만, CyclicBarrier는 재사용이 가능하여 반복적인 동기화 작업에 사용할 수 있습니다.\n\n📋 CountDownLatch vs CyclicBarrier:\n\n🔢 CountDownLatch (일회용):\n• 설정된 카운트가 0이 되면 대기 중인 스레드 해제\n• 카운트를 감소시킬 수는 있지만 증가 불가\n• 한 번 0이 되면 재사용 불가\n• N개의 작업 완료를 기다리는 용도\n\n🔄 CyclicBarrier (재사용 가능):\n• 지정된 수의 스레드가 모두 도달하면 함께 진행\n• 모든 스레드가 진행된 후 카운트 자동 리셋\n• 반복적인 동기화 지점으로 사용 가능\n• 병렬 알고리즘의 단계별 동기화\n\n💡 CountDownLatch 사용 예시:\n\n// 서비스 초기화 대기 시나리오\npublic class ServiceManager {\n    private final int serviceCount = 3;\n    private final CountDownLatch latch = new CountDownLatch(serviceCount);\n    \n    public void startServices() {\n        // 3개의 서비스를 비동기로 시작\n        new Thread(() -> {\n            initDatabaseService();\n            latch.countDown(); // 카운트 감소\n        }).start();\n        \n        new Thread(() -> {\n            initCacheService();\n            latch.countDown();\n        }).start();\n        \n        new Thread(() -> {\n            initWebService();\n            latch.countDown();\n        }).start();\n        \n        try {\n            latch.await(); // 모든 서비스 초기화 대기\n            System.out.println(\"모든 서비스 초기화 완료\");\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\n💡 CyclicBarrier 사용 예시:\n\n// 병렬 매트릭스 연산\npublic class MatrixMultiplier {\n    private final int threadCount = 4;\n    private final CyclicBarrier barrier = new CyclicBarrier(threadCount, () -> {\n        System.out.println(\"단계 완료!\"); // 모든 스레드 도달 시 실행\n    });\n    \n    public void multiplyInParallel() {\n        for (int phase = 0; phase < 3; phase++) { // 3단계 연산\n            final int currentPhase = phase;\n            \n            for (int i = 0; i < threadCount; i++) {\n                final int threadId = i;\n                new Thread(() -> {\n                    try {\n                        // 단계별 작업 수행\n                        performPhase(currentPhase, threadId);\n                        \n                        // 다른 스레드들 대기\n                        barrier.await();\n                        \n                    } catch (InterruptedException | BrokenBarrierException e) {\n                        Thread.currentThread().interrupt();\n                    }\n                }).start();\n            }\n        }\n    }\n}\n\n🔍 상세 비교:\n\n| 속성 | CountDownLatch | CyclicBarrier |\n|------|---------------|---------------|\n| 재사용성 | ❌ 일회용 | ✅ 재사용 |\n| 역할 | N개 작업 완료 대기 | N개 스레드 동기화 |\n| 대기 주체 | 여러 스레드 | 참여 스레드 모두 |\n| 액션 | countDown() | await() |\n| 콜백 | 없음 | 가능 |\n| 초기화 | 불가 | 자동 |\n\n🚀 성능 최적화:\n\n// 타임아웃 처리\ntry {\n    boolean completed = latch.await(5, TimeUnit.SECONDS);\n    if (!completed) {\n        System.out.println(\"타임아웃 발생\");\n    }\n} catch (InterruptedException e) {\n    Thread.currentThread().interrupt();\n}\n\n// CyclicBarrier 예외 처리\ntry {\n    barrier.await();\n} catch (BrokenBarrierException e) {\n    // 다른 스레드에서 예외 발생 또는 인터럽트\n    System.out.println(\"배리어가 깨졌습니다\");\n    barrier.reset(); // 배리어 리셋\n}\n\n📊 사용 사례 비교:\n\n**CountDownLatch 사용 사례:**\n• 애플리케이션 시작 시 여러 구성 요소 대기\n• 배치 작업에서 여러 파일 처리 완료 대기\n• 테스트에서 동시 시작 신호\n• 마스터-워커 패턴\n\n**CyclicBarrier 사용 사례:**\n• 병렬 알고리즘의 단계별 동기화\n• 시뮬레이션에서 라운드별 진행\n• 맵리듀스 작업의 중간 집계\n• 게임에서 라운드 기반 진행\n\n⚠️ 주의사항:\n\n1️⃣ 데드락 방지:\n• 타임아웃 설정 규장\n• 예외 발생 시 적절한 정리 및 리셋\n\n2️⃣ 자원 관리:\n• 인터럽트 신호 올바른 처리\n• 예외 발생 시 대기 중인 스레드 정리\n\n🎯 면접 팁: 각각의 사용 사례와 실제 구현 경험을 구체적으로 들 수 있으면 좋습니다."
    }
]
