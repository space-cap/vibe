[
    {
        "category": "Spring",
        "difficulty": "hard",
        "question": "Spring의 IoC(Inversion of Control) 컨테이너의 주요 기능은?",
        "options": [
            "의존성 주입과 빈 생명주기 관리",
            "웹 요청 처리",
            "데이터베이스 연결",
            "보안 인증"
        ],
        "correct": 0,
        "explanation": "IoC 컨테이너는 객체의 생성과 의존성 주입을 담당하며, 빈(Bean)의 생명주기를 관리하는 핵심 기능을 수행합니다.\n\n📋 IoC 컨테이너의 주요 역할:\n\n🏭 객체 생성 및 관리:\n• 애플리케이션 객체(빈)의 인스턴스화\n• 싱글톤, 프로토타입 등 스코프 관리\n• 객체 간 의존 관계 해결\n\n💉 의존성 주입 (DI):\n• 생성자 주입 (Constructor Injection)\n• 세터 주입 (Setter Injection)\n• 필드 주입 (Field Injection)\n\n🔄 빈 생명주기 관리:\n• 초기화 콜백: @PostConstruct, InitializingBean\n• 소멸 콜백: @PreDestroy, DisposableBean\n• 빈 후처리기 (BeanPostProcessor)\n\n🎯 IoC의 장점:\n• 결합도 감소 (Loose Coupling)\n• 테스트 용이성 향상\n• 코드 재사용성 증대\n• 관심사의 분리\n\n💡 설정 방법:\n• XML 기반: <bean> 태그\n• 애너테이션 기반: @Component, @Service, @Repository\n• Java Config: @Configuration, @Bean\n\n🔧 주요 컨테이너:\n• ApplicationContext: 기능이 풍부한 컨테이너\n• BeanFactory: 기본적인 DI 기능만 제공\n\n🎯 면접 팁: DI와 IoC의 개념 차이, Spring 없이 DI를 구현한다면 어떻게 할지도 생각해보세요."
    },
    {
        "category": "Spring",
        "difficulty": "medium",
        "question": "Spring에서 @Autowired의 동작 방식은?",
        "options": [
            "타입(Type) 기반으로 의존성 주입",
            "이름(Name) 기반으로 의존성 주입",
            "XML 설정에 따라 주입",
            "수동으로 객체 생성"
        ],
        "correct": 0,
        "explanation": "@Autowired는 타입(Type) 기반으로 의존성을 자동 주입하는 애너테이션입니다.\n\n📋 @Autowired 동작 원리:\n\n1️⃣ 타입 기반 매칭:\n• 먼저 해당 타입의 빈을 컨테이너에서 검색\n• 정확히 일치하는 타입의 빈을 찾아 주입\n\n2️⃣ 매칭 우선순위:\n• 타입이 정확히 일치하는 빈\n• 상속/구현 관계의 빈 (하위 타입)\n• 같은 타입의 빈이 여러 개면 예외 발생\n\n💡 사용 위치:\n@Autowired\nprivate UserService userService; // 필드 주입\n\n@Autowired\npublic void setUserService(UserService userService) { ... } // 세터 주입\n\n@Autowired\npublic UserController(UserService userService) { ... } // 생성자 주입\n\n⚠️ 여러 빈이 있을 때 해결 방법:\n\n1️⃣ @Qualifier 사용:\n@Autowired\n@Qualifier(\"userServiceImpl\")\nprivate UserService userService;\n\n2️⃣ @Primary 사용:\n@Primary\n@Service\npublic class UserServiceImpl implements UserService { ... }\n\n3️⃣ 빈 이름 지정:\n@Autowired\nprivate UserService userServiceImpl; // 빈 이름과 필드명 매칭\n\n🆚 다른 주입 애너테이션:\n• @Resource: 이름 기반 주입 (JSR-250)\n• @Inject: 타입 기반 주입 (JSR-330)\n\n✅ 권장사항:\n생성자 주입을 권장 (불변성, 테스트 용이성, 순환 의존성 검출)"
    },
    {
        "category": "Spring",
        "difficulty": "medium",
        "question": "Spring AOP에서 Aspect의 역할은?",
        "options": [
            "데이터베이스 트랜잭션 관리",
            "횡단 관심사를 모듈화",
            "웹 요청 라우팅",
            "객체 직렬화"
        ],
        "correct": 1,
        "explanation": "Aspect는 횡단 관심사(Cross-cutting Concerns)를 모듈화하여 핵심 비즈니스 로직과 분리하는 역할을 합니다.\n\n📋 AOP (Aspect-Oriented Programming) 핵심 개념:\n\n🎯 Aspect:\n• 횡단 관심사를 모듈화한 단위\n• 여러 객체에 공통으로 적용되는 기능\n• 예: 로깅, 보안, 트랜잭션, 캐싱\n\n🔧 주요 구성 요소:\n• Joinpoint: 적용 가능한 지점 (메서드 실행, 필드 접근 등)\n• Pointcut: 실제 적용할 지점을 선별하는 표현식\n• Advice: 실제 수행할 동작\n• Weaving: Aspect를 대상 객체에 적용하는 과정\n\n💡 Advice 종류:\n• @Before: 메서드 실행 전\n• @After: 메서드 실행 후\n• @AfterReturning: 메서드 정상 반환 후\n• @AfterThrowing: 예외 발생 후\n• @Around: 메서드 실행 전후 (가장 강력)\n\n🔧 사용 예시:\n@Aspect\n@Component\npublic class LoggingAspect {\n    @Around(\"@annotation(Loggable)\")\n    public Object logExecutionTime(ProceedingJoinPoint joinPoint) {\n        long start = System.currentTimeMillis();\n        Object result = joinPoint.proceed();\n        long end = System.currentTimeMillis();\n        log.info(\"Execution time: {}ms\", end - start);\n        return result;\n    }\n}\n\n🎯 장점:\n• 코드 중복 제거\n• 관심사의 분리\n• 모듈성 향상\n• 유지보수성 증대\n\n⚙️ Spring AOP 특징:\n• 프록시 기반 구현\n• 런타임 위빙\n• 메서드 레벨 인터셉션만 지원\n• AspectJ와 연동 가능"
    },
    {
        "category": "Spring",
        "difficulty": "easy",
        "question": "Spring Boot의 주요 특징이 아닌 것은?",
        "options": [
            "자동 설정(Auto Configuration)",
            "내장 톰캣 서버",
            "XML 설정 필수",
            "스타터 의존성"
        ],
        "correct": 2,
        "explanation": "Spring Boot는 XML 설정을 최소화하고 애너테이션 기반의 자동 설정을 제공합니다.\n\n📋 Spring Boot의 주요 특징:\n\n⚙️ 자동 설정 (Auto Configuration):\n• @SpringBootApplication 하나로 기본 설정 완료\n• Classpath의 라이브러리를 기반으로 자동 구성\n• 조건부 설정 (@ConditionalOnClass, @ConditionalOnProperty)\n\n🌐 내장 서버:\n• 톰캣, 제티, 언더토우 등 내장 서버 제공\n• JAR 파일 하나로 실행 가능한 애플리케이션\n• 별도 서버 설치 불필요\n\n📦 스타터 의존성 (Starter Dependencies):\n• spring-boot-starter-web: 웹 개발용\n• spring-boot-starter-data-jpa: JPA 데이터 액세스\n• spring-boot-starter-security: 보안 기능\n• 호환되는 라이브러리 버전 자동 관리\n\n📊 액추에이터 (Actuator):\n• 애플리케이션 모니터링과 관리 기능\n• 헬스 체크, 메트릭스, 설정 정보 제공\n• /actuator/health, /actuator/info 등 엔드포인트\n\n🚫 XML 설정 최소화:\n• 전통적인 Spring의 복잡한 XML 설정 불필요\n• Java Config와 애너테이션 기반 설정 권장\n• 필요시에만 선택적으로 XML 사용 가능\n\n💡 개발 편의 기능:\n• Spring Boot DevTools: 자동 재시작\n• application.properties/yml: 외부 설정\n• 프로파일 기반 설정 (@Profile)\n\n🎯 철학: \"Convention over Configuration\"\n설정보다는 관례를 따라 개발 생산성 극대화"
    },
    {
        "category": "Spring",
        "difficulty": "hard",
        "question": "Spring의 빈 스코프(Bean Scope) 중 session과 singleton의 차이점은?",
        "options": [
            "session은 세션별, singleton은 애플리케이션에 하나",
            "session은 애플리케이션에 하나, singleton은 세션별",
            "둘 다 동일한 스코프",
            "session은 웹에서만, singleton은 어디에서나 사용"
        ],
        "correct": 0,
        "explanation": "session 스코프는 HTTP 세션별로 빈을 생성하고, singleton은 Spring 컴테이너에 하나의 인스턴스만 생성합니다.\n\n📋 Spring Bean 스코프 종류:\n\n🏠 Singleton (기본 스코프):\n• Spring 컴테이너에 단 하나의 인스턴스만 살존\n• 동일한 빈 요청 시 언제나 같은 객체 반환\n• 컴테이너 시작 시 생성됨 (기본적으로)\n• 애플리케이션 종료 때까지 유지\n• 대부분의 서비스, 리포지토리 클래스에 사용\n\n🔄 Prototype:\n• 빈 요청할 때마다 새로운 인스턴스 생성\n• DI 시점에 생성됨\n• Spring이 생명주기 관리를 하지 않음 (소멸 콜백 없음)\n\n🌐 웹 관련 스코프 (웹 컴테이너에서만 사용):\n\n📝 Request:\n• HTTP 요청별로 빈 인스턴스 생성\n• 요청 처리 완료 시 소멸\n\n📧 Session:\n• HTTP 세션별로 빈 인스턴스 생성\n• 동일 세션 내에서는 같은 빈 인스턴스 사용\n• 세션 종료 시 소멸\n\n🌍 Application:\n• ServletContext 라이프사이클과 동일\n• 웹 애플리케이션 당 하나의 인스턴스\n\n🔌 WebSocket:\n• WebSocket 세션별로 빈 인스턴스 생성\n\n💡 스코프 설정 방법:\n\n1️⃣ 애너테이션 방식:\n@Component\n@Scope(\"singleton\") // 기본값이므로 생략 가능\npublic class SingletonService { }\n\n@Component\n@Scope(\"prototype\")\npublic class PrototypeService { }\n\n@Component\n@Scope(value = WebApplicationContext.SCOPE_SESSION, \n       proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class SessionService { }\n\n2️⃣ XML 방식:\n<bean id=\"singletonBean\" class=\"...\" scope=\"singleton\" />\n<bean id=\"prototypeBean\" class=\"...\" scope=\"prototype\" />\n\n3️⃣ Java Config:\n@Configuration\npublic class AppConfig {\n    @Bean\n    @Scope(\"prototype\")\n    public MyService myService() {\n        return new MyService();\n    }\n}\n\n🔧 프록시 모드 (Proxy Mode):\n\n• 웹 관련 스코프(request, session)는 프록시 필요\n• 이유: Singleton 빈이 진짜 객체를 참조하면 생명주기 불일치\n\n@Component\n@Scope(value = WebApplicationContext.SCOPE_REQUEST,\n       proxyMode = ScopedProxyMode.TARGET_CLASS) // CGLIB 프록시\npublic class RequestService { }\n\n@Component\n@Scope(value = WebApplicationContext.SCOPE_SESSION,\n       proxyMode = ScopedProxyMode.INTERFACES) // JDK 동적 프록시\npublic class SessionService implements MyInterface { }\n\n💡 실제 사용 예시:\n\n// 소비자 빈 (Singleton)\n@Service\npublic class OrderService {\n    \n    @Autowired\n    private SessionService sessionService; // 프록시 객체 주입\n    \n    public void createOrder() {\n        // 세션 스코프 빈 사용\n        sessionService.addToCart(\"item1\");\n    }\n}\n\n// 세션 스코프 빈\n@Component\n@Scope(value = WebApplicationContext.SCOPE_SESSION, \n       proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class SessionService {\n    private List<String> cart = new ArrayList<>();\n    \n    public void addToCart(String item) {\n        cart.add(item); // 세션별로 별도 상태 유지\n    }\n}\n\n📊 성능 및 메모리 영향:\n\n| 스코프 | 메모리 사용량 | 생성 비용 | 동시성 |\n|--------|----------|--------|--------|\n| Singleton | ⭐ 낮음 | ⭐⭐⭐ 한번 | ⚠️ 주의 |\n| Prototype | ⭐⭐⭐ 높음 | ⭐ 매번 | ⭐⭐⭐ 안전 |\n| Request | ⭐⭐ 보통 | ⭐⭐ 요청별 | ⭐⭐⭐ 안전 |\n| Session | ⭐⭐ 보통 | ⭐ 세션별 | ⭐⭐⭐ 안전 |\n\n⚠️ 주의사항:\n\n1️⃣ Singleton 상태 유지:\n• 인스턴스 변수를 변경 가능하게 설계하지 말 것\n• 동시성 문제를 고려하여 상태를 공유하지 말 것\n\n2️⃣ Prototype 생명주기:\n• Spring이 소멸 관리를 하지 않음\n• @PreDestroy 등 소멸 콜백이 호출되지 않음\n\n3️⃣ 웹 스코프 프록시:\n• 프록시 모드를 설정하지 않으면 오류 발생\n• 인터페이스 기반이라면 INTERFACES, 클래스 기반이라면 TARGET_CLASS\n\n🚀 모범 사례:\n\n// 비즈니스 로직 레이어 - Singleton\n@Service\npublic class OrderService {\n    // 상태를 갖지 않고 다른 싱글톤 빈들과 협력\n}\n\n// 사용자 별 상태 관리 - Session\n@Component\n@Scope(value = \"session\", proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class UserSession {\n    private String userId;\n    private List<String> shoppingCart;\n    // 세션 동안만 유지되는 상태\n}\n\n// 요청별 임시 데이터 - Request\n@Component\n@Scope(value = \"request\", proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class RequestContext {\n    private String requestId;\n    private Map<String, Object> attributes;\n    // 요청 처리 동안만 사용되는 데이터\n}\n\n🎯 면접 팁: 실제 웹 애플리케이션에서 다양한 스코프를 어떻게 활용했는지 경험을 들어주면 좋습니다."
    },
    {
        "category": "Spring",
        "difficulty": "medium",
        "question": "@Transactional 애너테이션의 전파 속성(propagation) 중 REQUIRED와 REQUIRES_NEW의 차이점은?",
        "options": [
            "REQUIRED는 새 트랜잭션, REQUIRES_NEW는 기존 참여",
            "REQUIRED는 기존 참여/새로 생성, REQUIRES_NEW는 항상 새 트랜잭션",
            "둘 다 동일한 동작",
            "REQUIRED는 읽기전용, REQUIRES_NEW는 쓰기전용"
        ],
        "correct": 1,
        "explanation": "REQUIRED는 기존 트랜잭션이 있으면 참여하고 없으면 새로 만들지만, REQUIRES_NEW는 항상 새로운 트랜잭션을 생성합니다.\n\n📋 트랜잭션 전파 속성 (Propagation):\n\n🌊 REQUIRED (기본값):\n• 기존 트랜잭션이 있으면 참여\n• 기존 트랜잭션이 없으면 새로 생성\n• 가장 일반적이고 기본적인 설정\n• 대부분의 비즈니스 로직에 적합\n\n🎆 REQUIRES_NEW:\n• 기존 트랜잭션이 있어도 새로운 트랜잭션 생성\n• 기존 트랜잭션은 일시 중단(suspend)\n• 새 트랜잭션 완료 후 기존 트랜잭션 재개\n• 독립적인 트랜잭션 필요 시 사용\n\n💡 상세 비교 예시:\n\n// 서비스 메서드\n@Service\npublic class OrderService {\n    \n    @Autowired\n    private PaymentService paymentService;\n    \n    @Autowired\n    private LogService logService;\n    \n    @Transactional // 기본적으로 REQUIRED\n    public void processOrder(Order order) {\n        // 1. 주문 저장 (REQUIRED 트랜잭션)\n        saveOrder(order);\n        \n        // 2. 결제 처리 (REQUIRED - 같은 트랜잭션)\n        paymentService.processPayment(order);\n        \n        // 3. 로그 기록 (REQUIRES_NEW - 새 트랜잭션)\n        logService.logOrder(order);\n    }\n}\n\n@Service\npublic class PaymentService {\n    \n    @Transactional(propagation = Propagation.REQUIRED)\n    public void processPayment(Order order) {\n        // 같은 트랜잭션에서 실행\n        // processOrder에서 예외 발생시 함께 롤백\n        payment.save(createPayment(order));\n    }\n}\n\n@Service\npublic class LogService {\n    \n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void logOrder(Order order) {\n        // 새로운 트랜잭션에서 실행\n        // processOrder에서 예외 발생해도 로그는 커밋됨\n        auditLog.save(createLog(order));\n    }\n}\n\n🔄 다른 전파 속성들:\n\n🚫 MANDATORY:\n• 기존 트랜잭션이 반드시 있어야 함\n• 없으면 예외 발생\n\n💫 NOT_SUPPORTED:\n• 트랜잭션 없이 실행\n• 기존 트랜잭션이 있으면 일시 중단\n\n⛔ NEVER:\n• 트랜잭션 없이 실행\n• 기존 트랜잭션이 있으면 예외 발생\n\n🌐 SUPPORTS:\n• 기존 트랜잭션이 있으면 참여\n• 없어도 상관없이 실행\n\n🔁 NESTED (JPA에서 지원하지 않음):\n• 기존 트랜잭션 내에 중첩 트랜잭션 생성\n• JDBC Savepoint 기능 사용\n\n📊 실제 사용 사례:\n\n**REQUIRED 사용 사례:**\n• 일반적인 비즈니스 로직 (주문, 결제, 재고처리)\n• 여러 엔티티를 한 번에 수정하는 작업\n• 데이터 일관성이 중요한 업무 로직\n\n**REQUIRES_NEW 사용 사례:**\n• 감사 로그, 통계 정보 기록\n• 알림, 메시지 발송\n• 메인 업무와 관계없이 반드시 수행되어야 할 작업\n• 예외 발생 시에도 로그는 남겨야 하는 경우\n\n💡 실제 구현 예시:\n\n@Service\n@Transactional\npublic class UserService {\n    \n    @Autowired\n    private EmailService emailService;\n    \n    @Autowired\n    private AuditService auditService;\n    \n    public void registerUser(User user) {\n        // 1. 사용자 등록 (REQUIRED 트랜잭션)\n        userRepository.save(user);\n        \n        // 2. 회원가입 이메일 발송 (REQUIRES_NEW)\n        // 이메일 발송 실패해도 회원가입은 성공\n        emailService.sendWelcomeEmail(user);\n        \n        // 3. 감사 로그 기록 (REQUIRES_NEW)\n        // 로그는 반드시 기록되어야 함\n        auditService.logUserRegistration(user);\n        \n        // 만약 여기서 예외가 발생하면:\n        // - user 등록은 롤백\n        // - 이메일 발송은 이미 커밋됨 (카테고리이캘다면 로그로 예외 기록)\n        // - 감사 로그도 이미 커밋됨\n        \n        if (someCondition) {\n            throw new RuntimeException(\"예외 발생!\");\n        }\n    }\n}\n\n@Service\npublic class EmailService {\n    \n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void sendWelcomeEmail(User user) {\n        try {\n            // 이메일 발송 로직\n            mailSender.send(createWelcomeEmail(user));\n            \n            // 발송 성공 기록\n            emailLogRepository.save(createEmailLog(user, \"SENT\"));\n        } catch (Exception e) {\n            // 발송 실패 기록\n            emailLogRepository.save(createEmailLog(user, \"FAILED\"));\n            // 예외를 다시 던지지 않으면 메인 트랜잭션에 영향 없음\n            log.error(\"이메일 발송 실패\", e);\n        }\n    }\n}\n\n⚠️ 주의사항:\n\n1️⃣ REQUIRES_NEW의 성능 영향:\n• 데이터베이스 커넥션 추가 사용\n• 트랜잭션 생성/커밋 비용 증가\n• 데드락 위험성 증가\n\n2️⃣ 데이터 일관성:\n• REQUIRES_NEW로 커밋된 데이터는 메인 트랜잭션 롤백 시에도 유지\n• 비즈니스 요구사항에 따라 신중히 선택\n\n3️⃣ 예외 처리:\n• REQUIRES_NEW 내에서 예외 발생 시 메인 트랜잭션에 전파\n• 예외를 catch해서 로깅만 하는 전략 고려\n\n🎯 면접 팁: 실제 프로젝트에서 언제 REQUIRES_NEW를 사용했는지, 어떤 문제를 해결했는지 구체적인 사례를 들어주는 것이 좋습니다."
    }
]
